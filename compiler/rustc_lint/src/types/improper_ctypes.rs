use std::iter;
use std::ops::ControlFlow;

use rustc_abi::{ExternAbi, VariantIdx};
use rustc_data_structures::fx::FxHashSet;
use rustc_errors::DiagMessage;
use rustc_hir as hir;
use rustc_hir::AmbigArg;
use rustc_hir::def::CtorKind;
use rustc_hir::intravisit::VisitorExt;
use rustc_middle::bug;
use rustc_middle::ty::{
    self, Adt, AdtKind, GenericArgsRef, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable,
    TypeVisitableExt,
};
use rustc_span::def_id::LocalDefId;
use rustc_span::{Span, sym};
use rustc_type_ir::{Binder,FnSig};
use tracing::debug;

use super::{
    CItemKind, IMPROPER_CTYPES, IMPROPER_CTYPES_DEFINITIONS, ImproperCTypesDeclarations,
    ImproperCTypesDefinitions, USES_POWER_ALIGNMENT, repr_nullable_ptr,
};
use crate::lints::{ImproperCTypes, ImproperCTypesLayer, UsesPowerAlignment};
use crate::{LateContext, LateLintPass, LintContext, fluent_generated as fluent};

type Sig<'tcx> = Binder<TyCtxt<'tcx>, FnSig<TyCtxt<'tcx>>>;

/// for a given `extern "ABI"`, tell wether that ABI is *not* considered a FFI boundary
fn fn_abi_is_internal(abi: ExternAbi) -> bool {
    matches!(
        abi,
        ExternAbi::Rust | ExternAbi::RustCall | ExternAbi::RustCold | ExternAbi::RustIntrinsic
    )
}



// a shorthand for an often used lifetime-region normalisation step
#[inline]
fn normalize_if_possible<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx>{
    cx.tcx.try_normalize_erasing_regions(cx.typing_env(), ty)
        .unwrap_or(ty)
}

// getting the (normalized) type out of a field (for, e.g., an enum variant or a tuple)
#[inline]
fn get_type_from_field<'tcx>(
    cx: &LateContext<'tcx>,
    field: &ty::FieldDef,
    args: GenericArgsRef<'tcx>,
) -> Ty<'tcx> {
    let field_ty = field.ty(cx.tcx, args);
    normalize_if_possible(cx, field_ty)
}


/// Check a variant of a non-exhaustive enum for improper ctypes
///
/// We treat `#[non_exhaustive] enum` as "ensure that code will compile if new variants are added".
/// This includes linting, on a best-effort basis. There are valid additions that are unlikely.
///
/// Adding a data-carrying variant to an existing C-like enum that is passed to C is "unlikely",
/// so we don't need the lint to account for it.
/// e.g. going from enum Foo { A, B, C } to enum Foo { A, B, C, D(u32) }.
pub(crate) fn check_non_exhaustive_variant(
    non_local_def: bool,
    variant: &ty::VariantDef,
) -> ControlFlow<DiagMessage, ()> {
    // non_exhaustive suggests it is possible that someone might break ABI
    // see: https://github.com/rust-lang/rust/issues/44109#issuecomment-537583344
    // so warn on complex enums being used outside their crate
    if non_local_def {
        // which is why we only warn about really_tagged_union reprs from https://rust.tf/rfc2195
        // with an enum like `#[repr(u8)] enum Enum { A(DataA), B(DataB), }`
        // but exempt enums with unit ctors like C's (e.g. from rust-bindgen)
        if variant_has_complex_ctor(variant) {
            return ControlFlow::Break(fluent::lint_improper_ctypes_non_exhaustive);
        }
    }

    let non_exhaustive_variant_fields = variant.is_field_list_non_exhaustive();
    if non_exhaustive_variant_fields && !variant.def_id.is_local() {
        return ControlFlow::Break(fluent::lint_improper_ctypes_non_exhaustive_variant);
    }

    ControlFlow::Continue(())
}

fn variant_has_complex_ctor(variant: &ty::VariantDef) -> bool {
    // CtorKind::Const means a "unit" ctor
    !matches!(variant.ctor_kind(), Some(CtorKind::Const))
}

// non_exhaustive suggests it is possible that someone might break ABI
// see: https://github.com/rust-lang/rust/issues/44109#issuecomment-537583344
// so warn on complex enums being used outside their crate
pub(crate) fn non_local_and_non_exhaustive(def: ty::AdtDef<'_>) -> bool {
    def.is_variant_list_non_exhaustive() && !def.did().is_local()
}

struct ImproperCTypesVisitor<'a, 'tcx> {
    cx: &'a LateContext<'tcx>,
    cache: FxHashSet<Ty<'tcx>>,
}

enum FfiResult<'tcx> {
    FfiSafe,
    FfiPhantom(Ty<'tcx>),
    FfiUnsafe {
        ty: Ty<'tcx>,
        reason: DiagMessage,
        help: Option<DiagMessage>,
    },
    FfiUnsafeWrapper {
        ty: Ty<'tcx>,
        reason: DiagMessage,
        help: Option<DiagMessage>,
        wrapped: Box<FfiResult<'tcx>>,
    },
}

/// Determine if a type is sized or not, and wether it affects references/pointers/boxes to it
#[derive(Clone, Copy)]
enum TypeSizedness {
    /// type of definite size (pointers are C-compatible)
    Definite,
    /// unsized type because it includes an opaque/foreign type (pointers are C-compatible)
    UnsizedWithExternType,
    /// unsized type for other reasons (slice, string, dyn Trait, closure, ...) (pointers are not C-compatible)
    UnsizedWithMetadata,
    /// not known, usually for placeholder types (Self in non-impl trait functions, type parameters, aliases, the like)
    NotYetKnown,
}

/// what type indirection points to a given type
#[derive(Clone, Copy)]
enum IndirectionType {
    /// box (valid non-null pointer, owns pointee)
    Box,
    /// ref (valid non-null pointer, borrows pointee)
    Ref,
    /// raw pointer (not necessarily non-null or valid. no info on ownership)
    RawPtr,
}

/// Is this type unsized because it contains (or is) a foreign type?
/// (Returns Err if the type happens to be sized after all)
fn get_type_sizedness<'tcx, 'a>(cx: &'a LateContext<'tcx>, ty: Ty<'tcx>) -> TypeSizedness {
    let tcx = cx.tcx;

    // note that sizedness is unrelated to inhabitedness
    if ty.is_sized(tcx, cx.typing_env()) {
        //let is_inh = ty.is_privately_uninhabited(tcx, cx.typing_env());
        TypeSizedness::Definite
    } else {
        // the overall type is !Sized or ?Sized
        match ty.kind() {
            ty::Slice(_) => TypeSizedness::UnsizedWithMetadata,
            ty::Str => TypeSizedness::UnsizedWithMetadata,
            ty::Dynamic(..) => TypeSizedness::UnsizedWithMetadata,
            ty::Foreign(..) => TypeSizedness::UnsizedWithExternType,
            ty::Adt(def, args) => {
                // for now assume: boxes and phantoms don't mess with this
                match def.adt_kind() {
                    AdtKind::Union | AdtKind::Enum => {
                        bug!("unions and enums are necessarily sized")
                    }
                    AdtKind::Struct => {
                        if let Some(sym::cstring_type | sym::cstr_type) =
                            tcx.get_diagnostic_name(def.did())
                        {
                            return TypeSizedness::UnsizedWithMetadata;
                        }

                        // FIXME: double-check: non-exhaustive structs from other crates are assumed to be ?Sized, right?
                        let is_non_exhaustive =
                            def.non_enum_variant().is_field_list_non_exhaustive();
                        if is_non_exhaustive && !def.did().is_local() {
                            return TypeSizedness::NotYetKnown;
                        }

                        if def.non_enum_variant().fields.is_empty() {
                            bug!("an empty struct is necessarily sized");
                        }

                        let variant = def.non_enum_variant();

                        // only the last field may be !Sized (or ?Sized in the case of type params)
                        let last_field = &variant.fields[(&variant.fields.len()-1).into()];
                        // let last_field = match &variant.fields.iter().last(){ // TODO performance
                        //     Some(last_field) => last_field,
                        //     None => bug!("Empty struct should be Sized, right?"), // TODO: nonexhaustive empty struct from another crate/module
                        // };
                        let field_ty = get_type_from_field(cx, last_field, args);
                        match get_type_sizedness(cx, field_ty) {
                            s @ (TypeSizedness::UnsizedWithMetadata
                            | TypeSizedness::UnsizedWithExternType
                            | TypeSizedness::NotYetKnown) => s,
                            TypeSizedness::Definite => {
                                bug!("failed to find the reason why struct `{:?}` is unsized", ty)
                            }
                        }
                    }
                }
            }
            ty::Tuple(tuple) => {
                // only the last field may be !Sized (or ?Sized in the case of type params)
                let item_ty: Ty<'tcx> = match tuple.last() {
                    Some(item_ty) => *item_ty,
                    None => bug!("Empty tuple (AKA unit type) should be Sized, right?"),
                };
                let item_ty = normalize_if_possible(cx, item_ty);
                match get_type_sizedness(cx, item_ty) {
                    s @ (TypeSizedness::UnsizedWithMetadata
                    | TypeSizedness::UnsizedWithExternType
                    | TypeSizedness::NotYetKnown) => s,
                    TypeSizedness::Definite => {
                        bug!("failed to find the reason why tuple `{:?}` is unsized", ty)
                    }
                }
            }

            ty_kind @ (ty::Bool
            | ty::Char
            | ty::Int(_)
            | ty::Uint(_)
            | ty::Float(_)
            | ty::Array(..)
            | ty::RawPtr(..)
            | ty::Ref(..)
            | ty::FnPtr(..)
            | ty::Never
            | ty::Pat(..) // these are (for now) numeric types with a range-based restriction
            ) => {
                // those types are all sized, right?
                bug!(
                    "This ty_kind (`{:?}`) should be sized, yet we are in a branch of code that deals with unsized types.",
                    ty_kind,
                )
            }

            // While opaque types are checked for earlier, if a projection in a struct field
            // normalizes to an opaque type, then it will reach ty::Alias(ty::Opaque) here.
            ty::Param(..) | ty::Alias(ty::Opaque | ty::Projection | ty::Inherent, ..) => {
                return TypeSizedness::NotYetKnown;
            }

            ty::UnsafeBinder(_) => todo!("FIXME(unsafe_binder)"),

            ty::Alias(ty::Weak, ..)
            | ty::Infer(..)
            | ty::Bound(..)
            | ty::Error(_)
            | ty::Closure(..)
            | ty::CoroutineClosure(..)
            | ty::Coroutine(..)
            | ty::CoroutineWitness(..)
            | ty::Placeholder(..)
            | ty::FnDef(..) => bug!("unexpected type in foreign function: {:?}", ty),
        }
    }
}

#[repr(u8)]
#[derive(Clone,Copy,Debug)]
enum CTypesVisitorState{
    // bitflags:
    // 0001: inner type
    // 0010: static
    // 0100: function return
    // 1000: used in declared function
    StaticTy = 0b0010,
    StaticInner = 0b0011,
    ArgumentTyInDefinition = 0b1000,
    ReturnTyInDefinition = 0b1100,
    ArgumentInnerInDefinition = 0b1001,
    ReturnInnerInDefinition = 0b1101,
    ArgumentTyInDeclaration = 0b0000,
    ReturnTyInDeclaration = 0b0100,
    ArgumentInnerInDeclaration = 0b0001,
    ReturnInnerInDeclaration = 0b0101,
}

impl CTypesVisitorState{
    /// wether we are being directly used in a function or static
    fn has_direct_use(self) -> bool {
        ((self as u8) & 0b0001) == 0
    }
    /// wether the type is used (directly or not) in a static variable
    fn is_in_static(self) -> bool {
        ((self as u8) & 0b0010) != 0
    }
    /// wether the type is used (directly or not) in a function, in return position
    fn is_in_function_return(self) -> bool {
        let ret = ((self as u8) & 0b0100) != 0;
        #[cfg(debug_assertions)]
        if ret{
            assert!(!self.is_in_static());
        }
        ret
    }
    /// wether the type is used (directly or not) in a defined function
    /// in other words, wether or not we allow non-FFI-safe types behind a C pointer,
    /// to be treated as an opaque type on the other side of the FFI boundary
    fn is_in_defined_function(self) -> bool {
        let ret = ((self as u8) & 0b1000) != 0;
        #[cfg(debug_assertions)]
        if ret{
            assert!(!self.is_in_static());
        }
        ret
    }
    /// get a new CTypesVisitorState from the current one, to visit the current type's inner types
    fn to_inner_ty(self) -> Self{
        //(self as u8 | 0b0001).try_into().unwrap()
        match self{
            Self::StaticTy|Self::StaticInner => Self::StaticInner,
            Self::ArgumentTyInDefinition|Self::ArgumentInnerInDefinition
              => Self::ArgumentInnerInDefinition,
            Self::ReturnTyInDefinition|Self::ReturnInnerInDefinition
              => Self::ReturnInnerInDefinition,
            Self::ArgumentTyInDeclaration|Self::ArgumentInnerInDeclaration
              => Self::ArgumentInnerInDeclaration,
            Self::ReturnTyInDeclaration|Self::ReturnInnerInDeclaration
              => Self::ReturnInnerInDeclaration,
        }
    }
}

impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {

    /// Checks wether an `extern "ABI" fn` function pointer is indeed FFI-safe to call
    fn visit_fnptr(
        &mut self,
          // TODO this feels wrong but rustc doesn't compile withoug that :')
        mode: CItemKind,
        ty: Ty<'tcx>,
        sig: Sig<'tcx>
    ) -> FfiResult<'tcx> {
        use FfiResult::*;
        debug_assert!(!fn_abi_is_internal(sig.abi()));
        let sig = self.cx.tcx.instantiate_bound_regions_with_erased(sig);
        let state = match mode {
            CItemKind::Declaration => CTypesVisitorState::ArgumentTyInDeclaration,
            CItemKind::Definition => CTypesVisitorState::ArgumentTyInDefinition,
        };
        for arg in sig.inputs() {
            match self.visit_type(state, *arg) {
                FfiSafe => {}
                r => {
                    return FfiUnsafeWrapper {
                        ty,
                        reason: fluent::lint_improper_ctypes_fnptr_indirect_reason,
                        help: None,
                        wrapped: Box::new(r),
                    };
                }
            }
        }

        let ret_ty = sig.output();
        let state = match mode {
            CItemKind::Declaration => CTypesVisitorState::ReturnTyInDeclaration,
            CItemKind::Definition => CTypesVisitorState::ReturnTyInDefinition,
        };

        match self.visit_type(state, ret_ty) {
            r @ (FfiSafe | FfiPhantom(_)) => r,
            r @ _ => FfiUnsafeWrapper {
                ty: ty.clone(),
                reason: fluent::lint_improper_ctypes_fnptr_indirect_reason,
                help: None,
                wrapped: Box::new(r),
            },
        }
    }

    /// Checks if the given indirection (box,ref,pointer) is "ffi-safe"
    fn visit_indirection(
        &mut self,
        state: CTypesVisitorState,
        ty: Ty<'tcx>,
        inner_ty: Ty<'tcx>,
        indirection_type: IndirectionType,
    ) -> FfiResult<'tcx> {
        use FfiResult::*;
        let tcx = self.cx.tcx;
        match get_type_sizedness(self.cx, inner_ty) {
            TypeSizedness::UnsizedWithExternType | TypeSizedness::Definite => {
                // there's a nuance on what this lint should do for
                // function definitions (`extern "C" fn fn_name(...) {...}`)
                // versus declarations (`unsafe extern "C" {fn fn_name(...);}`).
                // This is touched upon in https://github.com/rust-lang/rust/issues/66220
                // and https://github.com/rust-lang/rust/pull/72700
                //
                // The big question is: what does "ABI safety" mean? if you have something translated to a C pointer
                // (which has a stable layout) but points to FFI-unsafe type, is it safe?
                // On one hand, the function's ABI will match that of a similar C-declared function API,
                // on the other, dereferencing the pointer on the other side of the FFI boundary will be painful.
                // In this code, the opinion on is split between function declarations and function definitions,
                // with the idea that at least one side of the FFI boundary needs to treat the pointee as an opaque type.
                // For declarations, we see this as unsafe, but for definitions, we see this as safe.
                //
                // For extern function declarations, the actual definition of the function is written somewhere else,
                // meaning the declaration is free to express this opaqueness with an extern type (opaque caller-side) or a std::ffi::c_void (opaque callee-side)
                // (or other possibly better tricks, see https://doc.rust-lang.org/nomicon/ffi.html#representing-opaque-structs)
                // For extern function definitions, however, in the case where the type is opaque caller-side, it is not opaque callee-side,
                // and having the full type information is necessary to compile the function.
                if state.is_in_defined_function() {
                    return FfiSafe;
                } else {
                    let inner_res = self.visit_type(state.to_inner_ty(), inner_ty);
                    return match inner_res {
                        FfiSafe => inner_res,
                        _ => FfiUnsafeWrapper {
                            ty,
                            reason: fluent::lint_improper_ctypes_sized_ptr_to_unsafe_type,
                            wrapped: Box::new(inner_res),
                            help: None,
                        },
                    };
                }
            }
            TypeSizedness::NotYetKnown => {
                // types with sizedness NotYetKnown:
                // - Type params (with `variable: impl Trait` shorthand or not)
                //   (function definitions only, let's see how this interacts with monomorphisation)
                // - Self in trait functions/methods
                //   (FIXME note: function 'declarations' there should be treated as definitions)
                // - Opaque return types
                //   (always FFI-unsafe)
                // - non-exhaustive structs/enums/unions from other crates
                //   (always FFI-unsafe)
                // (for the three first, this is unless there is a `+Sized` bound involved)
                //
                // FIXME: on a side note, we should separate 'true' declarations (non-rust code),
                // 'fake' declarations (in traits, needed to be implemented elsewhere), and definitions.
                // (for instance, definitions should worry about &self with Self:?Sized, but fake declarations shouldn't)

                // wether they are FFI-safe or not does not depend on the indirections involved (&Self, &T, Box<impl Trait>),
                // so let's not wrap the current context around a potential FfiUnsafe type param.
                return self.visit_type(state.to_inner_ty(), inner_ty);
            }
            TypeSizedness::UnsizedWithMetadata => {
                let help = match inner_ty.kind() {
                    ty::Str => Some(fluent::lint_improper_ctypes_str_help),
                    ty::Slice(_) => Some(fluent::lint_improper_ctypes_slice_help),
                    ty::Adt(def, _)
                        if matches!(def.adt_kind(), AdtKind::Struct | AdtKind::Union)
                            && matches!(
                                // TODO also use that trick to separate closures from dyn, if possible
                                tcx.get_diagnostic_name(def.did()),
                                Some(sym::cstring_type | sym::cstr_type)
                            )
                            // TODO vv here vv : originally used acc.base_ty, needs more generic
                            && !ty.is_mutable_ptr() =>
                    {
                        Some(fluent::lint_improper_ctypes_cstr_help)
                    }
                    _ => None,
                };
                let reason = match indirection_type {
                    IndirectionType::RawPtr => fluent::lint_improper_ctypes_unsized_ptr,
                    IndirectionType::Ref => fluent::lint_improper_ctypes_unsized_ref,
                    IndirectionType::Box => fluent::lint_improper_ctypes_unsized_box,
                };
                FfiUnsafe { ty, reason, help }
            }
        }
    }

    /// Checks if the given `VariantDef`'s field types are "ffi-safe".
    fn visit_variant_fields(
        &mut self,
        state: CTypesVisitorState,
        ty: Ty<'tcx>,
        def: ty::AdtDef<'tcx>,
        variant: &ty::VariantDef,
        args: GenericArgsRef<'tcx>,
    ) -> FfiResult<'tcx> {
        use FfiResult::*;
        let transparent_with_all_zst_fields = if def.repr().transparent() {
            if let Some(field) = super::transparent_newtype_field(self.cx.tcx, variant) {
                // Transparent newtypes have at most one non-ZST field which needs to be checked..
                let field_ty = get_type_from_field(self.cx, field, args);
                match self.visit_type(state.to_inner_ty(), field_ty) {
                    FfiUnsafe { ty, .. } if ty.is_unit() => (),
                    r => return r,
                }

                false
            } else {
                // ..or have only ZST fields, which is FFI-unsafe (unless those fields are all
                // `PhantomData`).
                true
            }
        } else {
            false
        };

        // We can't completely trust `repr(C)` markings, so make sure the fields are actually safe.
        let mut all_phantom = !variant.fields.is_empty();
        for field in &variant.fields {
            let field_ty = get_type_from_field(self.cx, field, args);
            all_phantom &= match self.visit_type(state.to_inner_ty(), field_ty) {
                FfiSafe => false,
                // `()` fields are FFI-safe!
                FfiUnsafe { ty, .. } | FfiUnsafeWrapper { ty, .. } if ty.is_unit() => false,
                FfiPhantom(..) => true,
                r @ (FfiUnsafe { .. } | FfiUnsafeWrapper { .. }) => return r,
            }
        }

        if all_phantom {
            FfiPhantom(ty)
        } else if transparent_with_all_zst_fields {
            FfiUnsafe { ty, reason: fluent::lint_improper_ctypes_struct_zst, help: None }
        } else {
            FfiSafe
        }
    }

    fn visit_struct_union(
        &mut self,
        state: CTypesVisitorState,
        ty: Ty<'tcx>,
        def: ty::AdtDef<'tcx>,
        args: GenericArgsRef<'tcx>,
    ) -> FfiResult<'tcx> {
        debug_assert!(matches!(def.adt_kind(), AdtKind::Struct|AdtKind::Union));
        use FfiResult::*;

        if !def.repr().c() && !def.repr().transparent() {
            return FfiUnsafe {
                ty,
                reason: if def.is_struct() {
                    fluent::lint_improper_ctypes_struct_layout_reason
                } else {
                    fluent::lint_improper_ctypes_union_layout_reason
                },
                help: if def.is_struct() {
                    Some(fluent::lint_improper_ctypes_struct_layout_help)
                } else {
                    Some(fluent::lint_improper_ctypes_union_layout_help)
                },
            };
        }

        let is_non_exhaustive =
            def.non_enum_variant().is_field_list_non_exhaustive();
        if is_non_exhaustive && !def.did().is_local() {
            return FfiUnsafe {
                ty,
                reason: if def.is_struct() {
                    fluent::lint_improper_ctypes_struct_non_exhaustive
                } else {
                    fluent::lint_improper_ctypes_union_non_exhaustive
                },
                help: None,
            };
        }

        if def.non_enum_variant().fields.is_empty() {
            return FfiUnsafe {
                ty,
                reason: if def.is_struct() {
                    fluent::lint_improper_ctypes_struct_fieldless_reason
                } else {
                    fluent::lint_improper_ctypes_union_fieldless_reason
                },
                help: if def.is_struct() {
                    Some(fluent::lint_improper_ctypes_struct_fieldless_help)
                } else {
                    Some(fluent::lint_improper_ctypes_union_fieldless_help)
                },
            };
        }

        self.visit_variant_fields(state, ty, def, def.non_enum_variant(), args)
    }

    fn visit_enum(
        &mut self,
        state: CTypesVisitorState,
        ty: Ty<'tcx>,
        def: ty::AdtDef<'tcx>,
        args: GenericArgsRef<'tcx>,
    ) -> FfiResult<'tcx> {
        debug_assert!(matches!(def.adt_kind(), AdtKind::Enum));
        use FfiResult::*;

        if def.variants().is_empty() {
            // Empty enums are implicitely handled as the empty type:
            // values for them must never be constructed,
            // functions using them as argument or return must... err.
            // TODO
            return FfiSafe;
        }
        // Check for a repr() attribute to specify the size of the
        // discriminant.
        if !def.repr().c() && !def.repr().transparent() && def.repr().int.is_none()
        {
            // Special-case types like `Option<extern fn()>` and `Result<extern fn(), ()>`
            if let Some(ty) =
                repr_nullable_ptr(
                    self.cx.tcx,
                    self.cx.typing_env(),
                    ty,
                    if state.is_in_defined_function(){CItemKind::Definition}else{CItemKind::Declaration},
                )
            {
                return self.visit_type(state.to_inner_ty(), ty);
            }

            return FfiUnsafe {
                ty,
                reason: fluent::lint_improper_ctypes_enum_repr_reason,
                help: Some(fluent::lint_improper_ctypes_enum_repr_help),
            };
        }

        let non_local_def = non_local_and_non_exhaustive(def);
        // Check the contained variants.
        let ret = def.variants().iter().try_for_each(|variant| {
            check_non_exhaustive_variant(non_local_def, variant)
                .map_break(|reason| FfiUnsafe { ty, reason, help: None })?;

            match self.visit_variant_fields(state, ty, def, variant, args) {
                // TODO no need to pick only one
                FfiSafe => ControlFlow::Continue(()),
                r => ControlFlow::Break(r),
            }
        });
        if let ControlFlow::Break(result) = ret {
            return result;
        }

        FfiSafe
    }

    /// Checks if the given type is "ffi-safe" (has a stable, well-defined
    /// representation which can be exported to C code).
    fn visit_type(
        &mut self,
        state: CTypesVisitorState,
        ty: Ty<'tcx>,
    ) -> FfiResult<'tcx> {
        use FfiResult::*;

        let tcx = self.cx.tcx;

        // Protect against infinite recursion, for example
        // `struct S(*mut S);`.
        // FIXME: A recursion limit is necessary as well, for irregular
        // recursive types.
        if !self.cache.insert(ty) {
            return FfiSafe;
        }

        match *ty.kind() {
            ty::Adt(def, args) => {
                if let Some(inner_ty) = ty.boxed_ty() {
                    return self.visit_indirection(state, ty, inner_ty, IndirectionType::Box);
                }
                if def.is_phantom_data() {
                    return FfiPhantom(ty);
                }
                match def.adt_kind() {
                    AdtKind::Struct | AdtKind::Union => {
                        // I thought CStr could not be reached here:
                        //   - not using an indirection would cause a compile error prior to this lint
                        //   - and using one would cause the lint to catch on the indirection before reaching its pointee
                        // but for some reason one can just go and write function *pointers* like that:
                        // `type Foo = extern "C" fn(::std::ffi::CStr);`
                        if let Some(sym::cstring_type|sym::cstr_type) =
                            tcx.get_diagnostic_name(def.did())
                        {
                            return FfiUnsafe {
                                ty,
                                reason: fluent::lint_improper_ctypes_cstr_reason,
                                help: Some(fluent::lint_improper_ctypes_cstr_help), // TODO look into many cases: own/CString, ref/CString, own/struct/CString, ref/struct/CString, own/struct/ref/CString, etc...
                            };
                        }

                        self.visit_struct_union(state, ty, def, args)
                    }
                    AdtKind::Enum => {
                        self.visit_enum(state, ty, def, args)
                    }
                }
            }

            ty::Char => FfiUnsafe {
                ty,
                reason: fluent::lint_improper_ctypes_char_reason,
                help: Some(fluent::lint_improper_ctypes_char_help),
            },

            ty::Pat(..) => FfiUnsafe {
                ty,
                reason: fluent::lint_improper_ctypes_pat_reason,
                help: Some(fluent::lint_improper_ctypes_pat_help),
            },

            // FIXME: this should probably be architecture-dependant
            // same with some ty::Float variants.
            ty::Int(ty::IntTy::I128) | ty::Uint(ty::UintTy::U128) => {
                FfiUnsafe { ty, reason: fluent::lint_improper_ctypes_128bit, help: None }
            }

            // Primitive types with a stable representation.
            ty::Bool | ty::Int(..) | ty::Uint(..) | ty::Float(..) | ty::Never => FfiSafe,

            ty::Slice(_) => FfiUnsafe {
                ty,
                reason: fluent::lint_improper_ctypes_slice_reason,
                help: Some(fluent::lint_improper_ctypes_slice_help),
            },

            ty::Dynamic(..) => {
                FfiUnsafe { ty, reason: fluent::lint_improper_ctypes_dyn, help: None }
            }

            ty::Str => FfiUnsafe {
                ty,
                reason: fluent::lint_improper_ctypes_str_reason,
                help: Some(fluent::lint_improper_ctypes_str_help),
            },

            ty::Tuple(tuple) =>
                // TODO do we move the "unit types allowed as fields" here? assuming they are also allowed behind indirections
                // ...doesn't seem so. Existing logic doesn't like Boxes and refs to those.
                if tuple.is_empty() && state.is_in_function_return() && state.has_direct_use() {
                    // C functions can return void
                    FfiSafe
                } else {
                    FfiUnsafe {
                        ty,
                        reason: fluent::lint_improper_ctypes_tuple_reason,
                        help: Some(fluent::lint_improper_ctypes_tuple_help),
                    }
                },

            ty::RawPtr(ty, _)
                if match ty.kind() {
                    ty::Tuple(tuple) => tuple.is_empty(),
                    _ => false,
                } =>
            {
                FfiSafe
            }

            ty::RawPtr(inner_ty, _) => {
                return self.visit_indirection(state, ty, inner_ty, IndirectionType::RawPtr);
            }
            ty::Ref(_, inner_ty, _) => {
                return self.visit_indirection(state, ty, inner_ty, IndirectionType::Ref);
            }

            ty::Array(inner_ty, _) => {
                if state.has_direct_use() && !state.is_in_static() {
                    // C doesn't really support passing arrays by value - the only way to pass an array by value
                    // is through a struct.
                    FfiUnsafe{
                        ty,
                        reason:fluent::lint_improper_ctypes_array_reason,
                        help: Some(fluent::lint_improper_ctypes_array_help),
                    }
                } else {
                    self.visit_type(state.to_inner_ty(), inner_ty)
                }
            }

            ty::FnPtr(sig_tys, hdr) => {
                let sig = sig_tys.with(hdr);
                if fn_abi_is_internal(sig.abi()) {
                    FfiUnsafe {
                        ty,
                        reason: fluent::lint_improper_ctypes_fnptr_reason,
                        help: Some(fluent::lint_improper_ctypes_fnptr_help),
                    }
                } else {
                    let mode = if state.is_in_defined_function() {
                        CItemKind::Definition
                    } else {
                        CItemKind::Declaration
                    };
                    self.visit_fnptr(mode, ty, sig)
                }
            }

            ty::Foreign(..) => FfiSafe,

            // While opaque types are checked for earlier, if a projection in a struct field
            // normalizes to an opaque type, then it will reach this branch.
            ty::Alias(ty::Opaque, ..) => {
                FfiUnsafe { ty, reason: fluent::lint_improper_ctypes_opaque, help: None }
            }

            // `extern "C" fn` functions can have type parameters, which may or may not be FFI-safe,
            //  so they are currently ignored for the purposes of this lint.
            ty::Param(..) | ty::Alias(ty::Projection | ty::Inherent, ..)
                if state.is_in_defined_function() =>
            {
                FfiSafe
            }

            ty::UnsafeBinder(_) => todo!("FIXME(unsafe_binder)"),

            ty::Param(..)
            | ty::Alias(ty::Projection | ty::Inherent | ty::Weak, ..)
            | ty::Infer(..)
            | ty::Bound(..)
            | ty::Error(_)
            | ty::Closure(..)
            | ty::CoroutineClosure(..)
            | ty::Coroutine(..)
            | ty::CoroutineWitness(..)
            | ty::Placeholder(..)
            | ty::FnDef(..) => bug!("unexpected type in foreign function: {:?}", ty),
        }
    }

    fn check_for_opaque_ty(&mut self, ty: Ty<'tcx>) -> FfiResult<'tcx> {
        struct ProhibitOpaqueTypes;
        impl<'tcx> ty::visit::TypeVisitor<TyCtxt<'tcx>> for ProhibitOpaqueTypes {
            type Result = ControlFlow<Ty<'tcx>>;

            fn visit_ty(&mut self, ty: Ty<'tcx>) -> Self::Result {
                if !ty.has_opaque_types() {
                    return ControlFlow::Continue(());
                }

                if let ty::Alias(ty::Opaque, ..) = ty.kind() {
                    ControlFlow::Break(ty)
                } else {
                    ty.super_visit_with(self)
                }
            }
        }

        if let Some(ty) = ty
            .visit_with(&mut ProhibitOpaqueTypes)
            .break_value()
        {
            FfiResult::FfiUnsafe{
                ty,
                reason: fluent::lint_improper_ctypes_opaque,
                help: None,
            }
        } else {
            FfiResult::FfiSafe
        }
    }

    fn check_for_type(
        &mut self,
        state: CTypesVisitorState,
        ty: Ty<'tcx>,
    ) -> FfiResult<'tcx> {
        let ty = normalize_if_possible(self.cx, ty);

        match self.check_for_opaque_ty(ty) {
            FfiResult::FfiSafe => (),
            ffi_res @ _ => return ffi_res,
        }
        self.visit_type(state, ty)
    }

    fn check_for_fnptr(
        &mut self,
        mode: CItemKind,
        ty: Ty<'tcx>,
    ) -> FfiResult<'tcx> {
        let ty = normalize_if_possible(self.cx, ty);

        match self.check_for_opaque_ty(ty) {
            FfiResult::FfiSafe => (),
            ffi_res @ _ => return ffi_res,
        }

        match *ty.kind() {
            ty::FnPtr(sig_tys, hdr) => {
                let sig = sig_tys.with(hdr);
                if fn_abi_is_internal(sig.abi()) {
                    bug!("expected to inspect the type of an `extern \"ABI\"` FnPtr, not an internal-ABI one")
                } else {
                    self.visit_fnptr(mode, ty, sig)
                }
            },
            _ => bug!("expected to inspect the type of an `extern \"ABI\"` FnPtr, not whtaever this is"),
        }
    }
}

/// common structure for functionality that is shared
/// between ImproperCTypesDeclarations and ImproperCTypesDefinitions
struct ImproperCTypesLint<'c, 'tcx>{
    cx: &'c LateContext<'tcx>
}

impl<'c, 'tcx> ImproperCTypesLint<'c, 'tcx>{
    fn check_arg_for_power_alignment(
        &mut self,
        ty: Ty<'tcx>,
    ) -> bool {
        // Structs (under repr(C)) follow the power alignment rule if:
        //   - the first field of the struct is a floating-point type that
        //     is greater than 4-bytes, or
        //   - the first field of the struct is an aggregate whose
        //     recursively first field is a floating-point type greater than
        //     4 bytes.
        let tcx = self.cx.tcx;
        if tcx.sess.target.os != "aix" {
            return false;
        }
        if ty.is_floating_point() && ty.primitive_size(tcx).bytes() > 4 {
            return true;
        } else if let Adt(adt_def, _) = ty.kind()
            && adt_def.is_struct()
        {
            let struct_variant = adt_def.variant(VariantIdx::ZERO);
            // Within a nested struct, all fields are examined to correctly
            // report if any fields after the nested struct within the
            // original struct are misaligned.
            for struct_field in &struct_variant.fields {
                let field_ty = tcx.type_of(struct_field.did).instantiate_identity();
                if self.check_arg_for_power_alignment(field_ty) {
                    return true;
                }
            }
        }
        return false;
    }

    fn check_struct_for_power_alignment(
        &mut self,
        item: &'tcx hir::Item<'tcx>,
    ) {
        let tcx = self.cx.tcx;
        let adt_def = tcx.adt_def(item.owner_id.to_def_id());
        if adt_def.repr().c()
            && !adt_def.repr().packed()
            && tcx.sess.target.os == "aix"
            && !adt_def.all_fields().next().is_none()
        {
            let struct_variant_data = item.expect_struct().0;
            for (index, ..) in struct_variant_data.fields().iter().enumerate() {
                // Struct fields (after the first field) are checked for the
                // power alignment rule, as fields after the first are likely
                // to be the fields that are misaligned.
                if index != 0 {
                    let first_field_def = struct_variant_data.fields()[index];
                    let def_id = first_field_def.def_id;
                    let ty = tcx.type_of(def_id).instantiate_identity();
                    if self.check_arg_for_power_alignment(ty) {
                        self.cx.emit_span_lint(
                            USES_POWER_ALIGNMENT,
                            first_field_def.span,
                            UsesPowerAlignment,
                        );
                    }
                }
            }
        }
    }

    /// Find any fn-ptr types with external ABIs in `ty`.
    ///
    /// For example, `Option<extern "C" fn()>` returns `extern "C" fn()`
    fn check_type_for_external_abi_fnptr(
        &self,
        fn_mode: CItemKind,
        hir_ty: &hir::Ty<'tcx>,
        ty: Ty<'tcx>,
    ) {
        struct FnPtrFinder<'tcx> {
            spans: Vec<Span>,
            tys: Vec<Ty<'tcx>>,
        }

        impl<'tcx> hir::intravisit::Visitor<'_> for FnPtrFinder<'tcx> {
            fn visit_ty(&mut self, ty: &'_ hir::Ty<'_, AmbigArg>) {
                debug!(?ty);
                if let hir::TyKind::BareFn(hir::BareFnTy { abi, .. }) = ty.kind
                    && !fn_abi_is_internal(*abi)
                {
                    self.spans.push(ty.span);
                }

                hir::intravisit::walk_ty(self, ty)
            }
        }

        impl<'tcx> ty::visit::TypeVisitor<TyCtxt<'tcx>> for FnPtrFinder<'tcx> {
            type Result = ControlFlow<Ty<'tcx>>;

            fn visit_ty(&mut self, ty: Ty<'tcx>) -> Self::Result {
                if let ty::FnPtr(_, hdr) = ty.kind()
                    && !fn_abi_is_internal(hdr.abi)
                {
                    self.tys.push(ty);
                }

                ty.super_visit_with(self)
            }
        }

        let mut visitor = FnPtrFinder {spans: Vec::new(), tys: Vec::new() };
        ty.visit_with(&mut visitor);
        visitor.visit_ty_unambig(hir_ty);

        let all_types = iter::zip(visitor.tys.drain(..), visitor.spans.drain(..));
        all_types
            .map(|(fn_ptr_ty, span)|{
                // TODO this will probably lead to error deduplication: fix this
                let mut visitor = ImproperCTypesVisitor{cx: self.cx, cache: FxHashSet::default()};
                let ffi_res = visitor.check_for_fnptr(fn_mode, fn_ptr_ty);
                (span, ffi_res)
            })
            //.flatten()  // TODO already planning for more
              // even in function *definitions*, FnPtr:s are always function declarations. so it makes sense ...right?
            .map(|(span, ffi_res)|self.process_ffi_result(span, ffi_res, fn_mode))
            .reduce(|_a:(),_b:()|());
        //.drain();
    }

    /// For a function that doesn't need to be "ffi-safe", look for fn-ptr argument/return types
    /// that need to be checked for ffi-safety
    fn check_fn_for_external_abi_fnptr(
        &self,
        fn_mode: CItemKind,
        def_id: LocalDefId,
        decl: &'tcx hir::FnDecl<'_>
    ) {
        let sig = self.cx.tcx.fn_sig(def_id).instantiate_identity();
        let sig = self.cx.tcx.instantiate_bound_regions_with_erased(sig);

        for (input_ty, input_hir) in iter::zip(sig.inputs(), decl.inputs) {
            self.check_type_for_external_abi_fnptr(fn_mode, input_hir, *input_ty);
            // for (fn_ptr_ty, span) in self.find_fn_ptr_ty_with_external_abi(input_hir, *input_ty) {
            //     // no CTypesVisitorState needed, it's overwritten as soon as the FnPtr is entered
            //     // can default to ArgumentTyInDeclaration if needed
            //     let res = todo!(fn_ptr_ty);
            //     res.iter().map(|res|self.process_ffi_result(span, res)).drain();
            // }
        }

        if let hir::FnRetTy::Return(ret_hir) = decl.output {
            self.check_type_for_external_abi_fnptr(fn_mode, ret_hir, sig.output());
        }
    }


    /// Check that an extern "ABI" static variable is of a ffi-safe type
    fn check_foreign_static(
        &self,
        id: hir::OwnerId,
        span: Span
    ) {
        let ty = self.cx.tcx.type_of(id).instantiate_identity();
        let mut visitor = ImproperCTypesVisitor{cx: self.cx, cache: FxHashSet::default()};
        let ffi_res = visitor.check_for_type(CTypesVisitorState::StaticTy, ty);
        self.process_ffi_result(span, ffi_res, CItemKind::Declaration);
    }

    /// Check if a function's argument types and result type are "ffi-safe".
    fn check_foreign_fn(
        &self,
        fn_mode: CItemKind,
        def_id: LocalDefId,
        decl: &'tcx hir::FnDecl<'_>,
    ) {

        let sig = self.cx.tcx.fn_sig(def_id).instantiate_identity();
        let sig = self.cx.tcx.instantiate_bound_regions_with_erased(sig);

        for (input_ty, input_hir) in iter::zip(sig.inputs(), decl.inputs) {
            let mut visitor = ImproperCTypesVisitor{cx: self.cx, cache: FxHashSet::default()};
            let visit_state = match fn_mode{
                CItemKind::Definition => CTypesVisitorState::ArgumentTyInDefinition,
                CItemKind::Declaration => CTypesVisitorState::ArgumentTyInDeclaration,
            };
            let ffi_res = visitor.check_for_type(visit_state, *input_ty);
            self.process_ffi_result(input_hir.span, ffi_res, fn_mode);
        }

        if let hir::FnRetTy::Return(ret_hir) = decl.output {
            let mut visitor = ImproperCTypesVisitor{cx: self.cx, cache: FxHashSet::default()};
            let visit_state = match fn_mode{
                CItemKind::Definition => CTypesVisitorState::ReturnTyInDefinition,
                CItemKind::Declaration => CTypesVisitorState::ReturnTyInDeclaration,
            };
            let ffi_res = visitor.check_for_type(visit_state, sig.output());
            self.process_ffi_result(ret_hir.span, ffi_res, fn_mode);
        }
    }


    fn process_ffi_result(
        &self,
        sp: Span,
        res: FfiResult<'tcx>,
        fn_mode: CItemKind,
    ) {
        match res {
            FfiResult::FfiSafe => {}
            FfiResult::FfiPhantom(ty) => {
                self.emit_ffi_unsafe_type_lint(
                    ty.clone(),
                    sp,
                    vec![ImproperCTypesLayer {
                        ty,
                        note: fluent::lint_improper_ctypes_only_phantomdata,
                        span_note: None, // filled later
                        help: None,
                        inner_ty: None,
                    }],
                    fn_mode,
                );
            }
            FfiResult::FfiUnsafe { ty, reason, help } => {
                self.emit_ffi_unsafe_type_lint(
                    ty.clone(),
                    sp,
                    vec![ImproperCTypesLayer {
                        ty,
                        help,
                        note: reason,
                        span_note: None, // filled later
                        inner_ty: None,
                    }],
                    fn_mode,
                );
            }
            ffir @ FfiResult::FfiUnsafeWrapper { .. } => {
                let mut ffiresult_recursor = ControlFlow::Continue(&ffir);
                let mut cimproper_layers: Vec<ImproperCTypesLayer<'_>> = vec![];

                // this whole while block converts the arbitrarily-deep
                // FfiResult stack to an ImproperCTypesLayer Vec
                while let ControlFlow::Continue(ref ffir_rec) = ffiresult_recursor {
                    match ffir_rec {
                        FfiResult::FfiPhantom(ty) => {
                            if let Some(layer) = cimproper_layers.last_mut() {
                                layer.inner_ty = Some(ty.clone());
                            }
                            cimproper_layers.push(ImproperCTypesLayer {
                                ty: ty.clone(),
                                inner_ty: None,
                                help: None,
                                note: fluent::lint_improper_ctypes_only_phantomdata,
                                span_note: None, // filled later
                            });
                            ffiresult_recursor = ControlFlow::Break(());
                        }
                        FfiResult::FfiUnsafe { ty, reason, help }
                        | FfiResult::FfiUnsafeWrapper { ty, reason, help, .. } => {
                            if let Some(layer) = cimproper_layers.last_mut() {
                                layer.inner_ty = Some(ty.clone());
                            }
                            cimproper_layers.push(ImproperCTypesLayer {
                                ty: ty.clone(),
                                inner_ty: None,
                                help: help.clone(),
                                note: reason.clone(),
                                span_note: None, // filled later
                            });

                            if let FfiResult::FfiUnsafeWrapper { wrapped, .. } = ffir_rec {
                                ffiresult_recursor = ControlFlow::Continue(wrapped.as_ref());
                            } else {
                                ffiresult_recursor = ControlFlow::Break(());
                            }
                        }
                        FfiResult::FfiSafe => {
                            bug!("malformed FfiResult stack: it should be unsafe all the way down")
                        }
                    };
                }
                // should always have at least one type
                let last_ty = cimproper_layers.last().unwrap().ty.clone();
                self.emit_ffi_unsafe_type_lint(last_ty, sp, cimproper_layers, fn_mode);
            }
        }
    }

    fn emit_ffi_unsafe_type_lint(
        &self,
        ty: Ty<'tcx>,
        sp: Span,
        mut reasons: Vec<ImproperCTypesLayer<'tcx>>,
        fn_mode: CItemKind,
    ) {
        let lint = match fn_mode {
            CItemKind::Declaration => IMPROPER_CTYPES,
            CItemKind::Definition => IMPROPER_CTYPES_DEFINITIONS,
        };
        let desc = match fn_mode {
            CItemKind::Declaration => "block",
            CItemKind::Definition => "fn",
        };
        for reason in reasons.iter_mut() {
            reason.span_note = if let ty::Adt(def, _) = reason.ty.kind()
                && let Some(sp) = self.cx.tcx.hir().span_if_local(def.did())
            {
                Some(sp)
            } else {
                None
            };
        }

        self.cx.emit_span_lint(lint, sp, ImproperCTypes { ty, desc, label: sp, reasons });
    }

}

impl<'tcx> LateLintPass<'tcx> for ImproperCTypesDeclarations {
    fn check_foreign_item(&mut self, cx: &LateContext<'tcx>, it: &hir::ForeignItem<'tcx>) {

        let abi = cx.tcx.hir().get_foreign_abi(it.hir_id());
        let lint = ImproperCTypesLint{cx};

        match it.kind {
            hir::ForeignItemKind::Fn(sig, _, _) => {
                if fn_abi_is_internal(abi) {
                    lint.check_fn_for_external_abi_fnptr(
                        CItemKind::Declaration,
                        it.owner_id.def_id,
                        sig.decl
                    )
                } else {
                    lint.check_foreign_fn(CItemKind::Declaration, it.owner_id.def_id, sig.decl);
                }
            }
            hir::ForeignItemKind::Static(ty, _, _) if !fn_abi_is_internal(abi) => {
                lint.check_foreign_static(it.owner_id, ty.span);
            }
            hir::ForeignItemKind::Static(..) | hir::ForeignItemKind::Type => (),
        }
    }
}

/// `ImproperCTypesDefinitions` checks items outside of foreign items (e.g. stuff that isn't in
/// `extern "C" { }` blocks):
///
/// - `extern "<abi>" fn` definitions are checked in the same way as the
///   `ImproperCtypesDeclarations` visitor checks functions if `<abi>` is external (e.g. "C").
/// - All other items which contain types (e.g. other functions, struct definitions, etc) are
///   checked for extern fn-ptrs with external ABIs.
impl<'tcx> LateLintPass<'tcx> for ImproperCTypesDefinitions {
    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {
        match item.kind {
            hir::ItemKind::Static(ty, ..)
            | hir::ItemKind::Const(ty, ..)
            | hir::ItemKind::TyAlias(ty, ..) => {
                ImproperCTypesLint{cx}.check_type_for_external_abi_fnptr(
                    CItemKind::Definition,
                    ty,
                    cx.tcx.type_of(item.owner_id).instantiate_identity(),
                );
            }
            // See `check_fn`..
            hir::ItemKind::Fn { .. } => {}
            // Structs are checked based on if they follow the power alignment
            // rule (under repr(C)).
            hir::ItemKind::Struct(..) => {
                ImproperCTypesLint{cx}.check_struct_for_power_alignment(item);
            }
            // See `check_field_def`..
            hir::ItemKind::Union(..) | hir::ItemKind::Enum(..) => {}
            // Doesn't define something that can contain a external type to be checked.
            hir::ItemKind::Impl(..)
            | hir::ItemKind::TraitAlias(..)
            | hir::ItemKind::Trait(..)
            | hir::ItemKind::GlobalAsm(..)
            | hir::ItemKind::ForeignMod { .. }
            | hir::ItemKind::Mod(..)
            | hir::ItemKind::Macro(..)
            | hir::ItemKind::Use(..)
            | hir::ItemKind::ExternCrate(..) => {}
        }
    }

    fn check_field_def(&mut self, cx: &LateContext<'tcx>, field: &'tcx hir::FieldDef<'tcx>) {
        ImproperCTypesLint{cx}.check_type_for_external_abi_fnptr(
            CItemKind::Definition,
            field.ty,
            cx.tcx.type_of(field.def_id).instantiate_identity(),
        );
    }

    fn check_fn(
        &mut self,
        cx: &LateContext<'tcx>,
        kind: hir::intravisit::FnKind<'tcx>,
        decl: &'tcx hir::FnDecl<'_>,
        _: &'tcx hir::Body<'_>,
        _: Span,
        id: LocalDefId,
    ) {
        use hir::intravisit::FnKind;

        let abi = match kind {
            FnKind::ItemFn(_, _, header, ..) => header.abi,
            FnKind::Method(_, sig, ..) => sig.header.abi,
            _ => return,
        };

        let lint = ImproperCTypesLint{cx};
        if fn_abi_is_internal(abi) {
            lint.check_fn_for_external_abi_fnptr(CItemKind::Definition,id, decl);
        } else {
            lint.check_foreign_fn(CItemKind::Definition, id, decl);
        }
    }
}
